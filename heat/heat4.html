<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>物理實驗室：物質的三態變化 (v4)</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f0f2f5; margin: 0; padding: 20px; color: #333; }
        .container { position: relative; max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
        h1 { text-align: center; color: #2c3e50; }
        
        /* 署名樣式 */
        .designer-signature {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 0.85rem;
            color: #7f8c8d;
            font-weight: bold;
            font-style: italic;
            z-index: 1000;
            font-family: 'Georgia', serif;
            pointer-events: none;
            text-align: right;
            line-height: 1.4;
        }

        /* Layout for 3 canvases */
        .main-display { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; align-items: flex-start; }
        
        /* Canvas Styles */
        .canvas-box { position: relative; border: 2px solid #ddd; border-radius: 10px; overflow: hidden; background: #fafafa; width: 350px; height: 350px; }
        canvas { display: block; width: 100%; height: 100%; }
        .label { position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.9); padding: 5px 10px; border-radius: 5px; font-weight: bold; border: 1px solid #ccc; font-size: 14px; z-index: 10;}
        
        /* Controls */
        .controls { margin-top: 20px; padding: 20px; background: #e8f4f8; border-radius: 10px; text-align: center; }
        
        .control-row { display: flex; align-items: center; justify-content: center; gap: 15px; margin-bottom: 15px; }
        
        /* Styled Slider */
        input[type=range] { flex-grow: 1; max-width: 600px; cursor: pointer; height: 8px; border-radius: 5px; background: #d3d3d3; outline: none; -webkit-appearance: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 25px; height: 25px; border-radius: 50%; background: #e74c3c; cursor: pointer; border: 2px solid white; box-shadow: 0 0 5px rgba(0,0,0,0.3); }

        /* Buttons */
        button { padding: 10px 20px; font-size: 16px; border: none; border-radius: 5px; cursor: pointer; transition: background 0.3s; font-weight: bold; }
        .btn-play { background-color: #27ae60; color: white; }
        .btn-play:hover { background-color: #219150; }
        .btn-pause { background-color: #e67e22; color: white; }
        .btn-reset { background-color: #95a5a6; color: white; }
        
        /* Text Info */
        .status-panel { margin-top: 15px; display: grid; grid-template-columns: 1fr 1fr; gap: 20px; text-align: left; }
        .info-box { background: white; padding: 15px; border-radius: 8px; border-left: 5px solid #3498db; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        .highlight { color: #e74c3c; font-weight: bold; font-size: 1.1em; }
        .rope-status { color: #8e44ad; font-weight: bold; }

        /* Animation for Phase Change UI */
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
        .phase-changing { animation: pulse 2s infinite; border-left-color: #f1c40f; }
    </style>
</head>
<body>

<div class="container">
    <!-- 簽名標註 -->
    <div class="designer-signature">&lt;Designed by 黃鈺心,<br>Gemini Canvas輔助生成&gt;</div>

    <h1>物理實驗室：物質受熱的三態變化</h1>
    
    <div class="main-display">
        <!-- 粒子視圖 -->
        <div class="canvas-box">
            <canvas id="particleCanvas" width="350" height="350"></canvas>
            <!-- Modified label as requested -->
            <div class="label">微觀：粒子運動</div>
        </div>
        
        <!-- 巨觀視圖 -->
        <div class="canvas-box">
            <canvas id="macroCanvas" width="350" height="350"></canvas>
            <div class="label">巨觀：物質狀態</div>
        </div>

        <!-- 圖表視圖 -->
        <div class="canvas-box">
            <canvas id="graphCanvas" width="350" height="350"></canvas>
            <div class="label">加熱曲線圖</div>
        </div>
    </div>

    <div class="controls">
        <div class="control-row">
            <button id="playBtn" class="btn-play">▶ 開始自動加熱</button>
            <button id="resetBtn" class="btn-reset">↺ 重置</button>
        </div>
        
        <div class="control-row">
            <span>低溫 (-20°C)</span>
            <input type="range" id="heatSlider" min="0" max="1000" value="0">
            <span>高溫 (>200°C)</span>
        </div>
        
        <div class="status-panel">
            <div class="info-box" id="tempDisplayBox">
                <p>目前溫度：<span id="tempValue" class="highlight">-20</span> °C</p>
                <p>物質狀態：<span id="stateValue">固體</span></p>
                <p>加熱進度：<span id="progressValue">0</span> / 1000</p>
            </div>
            <div class="info-box" id="descBox">
                <p>粒子行為：<span id="behaviorValue">粒子緊密堆疊，在原地震動。</span></p>
                <p>繩子狀態：<span id="ropeValue" class="rope-status">繩子很短且緊繃，綁住所有粒子。</span></p>
            </div>
        </div>
    </div>
</div>

<script>
    // Config
    const canvas = document.getElementById('particleCanvas');
    const ctx = canvas.getContext('2d');
    const graphCanvas = document.getElementById('graphCanvas');
    const gCtx = graphCanvas.getContext('2d');
    const macroCanvas = document.getElementById('macroCanvas');
    const mCtx = macroCanvas.getContext('2d');
    
    const slider = document.getElementById('heatSlider');
    const playBtn = document.getElementById('playBtn');
    const resetBtn = document.getElementById('resetBtn');
    
    // UI Elements
    const tempValEl = document.getElementById('tempValue');
    const stateValEl = document.getElementById('stateValue');
    const behaviorValEl = document.getElementById('behaviorValue');
    const ropeValEl = document.getElementById('ropeValue');
    const progressValEl = document.getElementById('progressValue');
    const descBox = document.getElementById('descBox');

    // Physics Constants
    const NUM_PARTICLES = 64; 
    const COLS = 8;
    const P_RADIUS = 5; 
    
    // State Variables
    let time = 0;
    let temperature = -20;
    let particles = [];
    let isPlaying = false;
    let animationId;
    let frameCount = 0; // For slowing down animation
    
    // Initialize Particles (Centered Block)
    function initParticles() {
        particles = [];
        let offsetX = (canvas.width - (COLS * 20)) / 2; 
        let offsetY = (canvas.height - (COLS * 20)) / 2;

        for(let i=0; i<NUM_PARTICLES; i++) {
            let r = Math.floor(i / COLS);
            let c = i % COLS;
            
            let randomMeltDelay = Math.random() * 200; 
            
            particles.push({
                x: offsetX + c * 20,
                y: offsetY + r * 20,
                baseX: offsetX + c * 20,
                baseY: offsetY + r * 20,
                vx: 0,
                vy: 0,
                phaseOffset: Math.random() * Math.PI * 2,
                meltStartAt: 200 + randomMeltDelay
            });
        }
    }

    // Auto Heat Logic
    function togglePlay() {
        isPlaying = !isPlaying;
        if (isPlaying) {
            playBtn.textContent = "⏸ 暫停加熱";
            playBtn.className = "btn-pause";
        } else {
            playBtn.textContent = "▶ 繼續自動加熱";
            playBtn.className = "btn-play";
        }
    }
    
    playBtn.addEventListener('click', togglePlay);
    
    resetBtn.addEventListener('click', () => {
        isPlaying = false;
        playBtn.textContent = "▶ 開始自動加熱";
        playBtn.className = "btn-play";
        slider.value = 0;
        time = 0;
        frameCount = 0;
        initParticles(); // Reset positions
    });

    slider.addEventListener('input', () => {
        if(isPlaying) togglePlay();
    });

    // Physics Logic Update
    function updatePhysics(t) {
        let state = "";
        let ropeStatus = "";
        let behavior = "";
        let isPhaseChange = false;

        if (t <= 200) {
            // Solid Heating (-20 to 30)
            state = "固體";
            temperature = -20 + (t / 200) * 50; 
            ropeStatus = "繩子很短且緊繃，綁住所有粒子。";
            behavior = "粒子在晶格內震動，動能增加。";
        } else if (t <= 400) {
            // Melting (30 constant)
            state = "固液共存 (熔化中)";
            temperature = 30;
            isPhaseChange = true;
            ropeStatus = "部分繩子被拉長，部分粒子開始脫離束縛。";
            behavior = "固體結構逐漸崩解，粒子一顆一顆變自由。";
        } else if (t <= 700) {
            // Liquid Heating (30 to 200)
            state = "液體";
            temperature = 30 + ((t - 400) / 300) * 170; 
            ropeStatus = "繩子很鬆，粒子間有弱連結，形成流體。";
            behavior = "粒子自由滑動、流轉，呈現液態。";
        } else if (t <= 900) {
            // Boiling (200 constant)
            state = "液氣共存 (汽化中)";
            temperature = 200;
            isPhaseChange = true;
            ropeStatus = "能量正在剪斷繩子！粒子飛出！";
            behavior = "劇烈沸騰，粒子脫離液體表面飛向空間。";
        } else {
            // Gas Heating (>200)
            state = "氣體";
            temperature = 200 + ((t - 900) / 100) * 50; 
            ropeStatus = "繩子全斷了！無束縛。";
            behavior = "粒子高速自由飛散，充滿整個空間。";
        }

        // Update UI
        tempValEl.innerText = Math.round(temperature);
        stateValEl.innerText = state;
        ropeValEl.innerText = ropeStatus;
        behaviorValEl.innerText = behavior;
        progressValEl.innerText = t;
        
        if(isPhaseChange) descBox.classList.add('phase-changing');
        else descBox.classList.remove('phase-changing');

        return { state, temperature };
    }

    function drawParticles(stateVal) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        let speedFactor = (temperature + 40) / 50; 
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        particles.forEach((p, index) => {
            let isMeltingPhase = (time >= 200 && time <= 400);
            let isParticleLiquid = (time > 400) || (isMeltingPhase && time >= p.meltStartAt);
            
            // --- MOVEMENT LOGIC ---
            if (!isParticleLiquid) {
                // SOLID BEHAVIOR
                let tempForVib = isMeltingPhase ? 30 : temperature;
                let vibration = (tempForVib + 30) / 50 * 1.5; 
                p.x = p.baseX + Math.sin(Date.now()/50 + p.phaseOffset) * vibration;
                p.y = p.baseY + Math.cos(Date.now()/50 + p.phaseOffset) * vibration;
            } else {
                // LIQUID / GAS BEHAVIOR
                if (stateVal.includes("汽化") || stateVal === "氣體") {
                    let boilRatio = (time - 700) / 200;
                    let isGas = stateVal === "氣體";
                    let isFreeGas = isGas || (Math.random() < boilRatio * 0.05);

                    if (isFreeGas || (Math.abs(p.vx) > 1 || Math.abs(p.vy) > 1)) {
                         // Gas Motion
                         if (Math.abs(p.vx) < 1) { 
                             let angle = Math.random() * Math.PI * 2;
                             p.vx = Math.cos(angle) * 5;
                             p.vy = Math.sin(angle) * 5;
                         }
                         p.x += p.vx;
                         p.y += p.vy;
                         if(p.x < P_RADIUS) { p.x = P_RADIUS; p.vx *= -1; }
                         if(p.x > canvas.width - P_RADIUS) { p.x = canvas.width - P_RADIUS; p.vx *= -1; }
                         if(p.y < P_RADIUS) { p.y = P_RADIUS; p.vy *= -1; }
                         if(p.y > canvas.height - P_RADIUS) { p.y = canvas.height - P_RADIUS; p.vy *= -1; }
                    } else {
                        applyLiquidMotion(p, speedFactor, centerX, centerY);
                    }
                } else {
                    applyLiquidMotion(p, speedFactor, centerX, centerY);
                }
            }

            // --- DRAWING ---
            ctx.beginPath();
            ctx.fillStyle = getParticleColor(temperature);
            ctx.arc(p.x, p.y, P_RADIUS, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw Ropes
            drawRopes(p, index, isParticleLiquid);
        });
    }
    
    function applyLiquidMotion(p, speedFactor, centerX, centerY) {
        p.x += (Math.random() - 0.5) * speedFactor * 1.5;
        p.y += (Math.random() - 0.5) * speedFactor * 1.5;
        let dx = p.x - centerX;
        let dy = p.y - centerY;
        let dist = Math.sqrt(dx*dx + dy*dy);
        let maxRadius = 110; 
        if (dist > maxRadius) {
            p.x -= (dx / dist) * 1.0; 
            p.y -= (dy / dist) * 1.0;
        }
    }

    function drawRopes(p, index, isSourceLiquid) {
        // Requested Modification: Remove ropes completely if in full Gas state
        // Full gas starts at time > 900
        if (time > 900) return;

        let neighborsToCheck = [index + 1, index + COLS];
        
        neighborsToCheck.forEach(nIdx => {
            if (nIdx >= 0 && nIdx < particles.length) {
                let neighbor = particles[nIdx];
                let isMeltingPhase = (time >= 200 && time <= 400);
                let isNeighborLiquid = (time > 400) || (isMeltingPhase && time >= neighbor.meltStartAt);

                let dx = p.x - neighbor.x;
                let dy = p.y - neighbor.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                
                let type = "loose";
                let limit = 50;

                if (!isSourceLiquid && !isNeighborLiquid) {
                    type = "tight";
                    limit = 30;
                } else if (isSourceLiquid !== isNeighborLiquid) {
                    type = "stretching"; 
                    limit = 45;
                }
                
                if (temperature >= 200) limit = 60;

                if (dist < limit) {
                    ctx.beginPath();
                    ctx.strokeStyle = "#8e44ad"; 
                    ctx.lineWidth = (type === "tight") ? 2 : 1;
                    
                    if(type === "stretching") ctx.setLineDash([3, 3]);
                    else ctx.setLineDash([]);
                    
                    ctx.moveTo(p.x, p.y); 
                    ctx.lineTo(neighbor.x, neighbor.y); 
                    ctx.stroke();
                }
            }
        });
    }

    function getParticleColor(temp) {
        if (temp < 0) return "#3498db"; 
        if (temp < 100) return "#9b59b6"; 
        return "#e74c3c"; 
    }

    function drawMacro(currentTime) {
        mCtx.clearRect(0, 0, macroCanvas.width, macroCanvas.height);
        
        // Draw Beaker
        mCtx.strokeStyle = "#555";
        mCtx.lineWidth = 4;
        mCtx.beginPath();
        mCtx.moveTo(75, 50);
        mCtx.lineTo(75, 300); 
        mCtx.lineTo(275, 300); 
        mCtx.lineTo(275, 50); 
        mCtx.stroke();
        
        // Draw Flame
        if (currentTime > 0 && currentTime < 1000) {
            mCtx.fillStyle = "orange";
            mCtx.beginPath();
            let flick = Math.random() * 5;
            mCtx.moveTo(150, 310);
            mCtx.lineTo(200, 310);
            mCtx.lineTo(175 + flick, 340); 
            mCtx.fill();
            mCtx.fillStyle = "red";
            mCtx.beginPath();
            mCtx.moveTo(160, 310);
            mCtx.lineTo(190, 310);
            mCtx.lineTo(175 - flick, 330);
            mCtx.fill();
            mCtx.fillStyle = "#333";
            mCtx.font = "14px Arial";
            // mCtx.fillText("加熱中...", 150, 360); // Removed per user preference to keep clean
        }

        // Draw Content based on phase - Labels Removed as requested
        if (time <= 200) {
            // Solid Block
            mCtx.fillStyle = "#3498db";
            mCtx.fillRect(125, 200, 100, 100); 
        } else if (time <= 400) {
            // Melting
            let meltRatio = (time - 200) / 200; 
            let waterHeight = 30 * meltRatio;
            mCtx.fillStyle = "rgba(52, 152, 219, 0.6)"; 
            mCtx.fillRect(77, 300 - waterHeight, 196, waterHeight);
            
            let size = 100 * (1 - meltRatio * 0.8); 
            let offset = (100 - size) / 2;
            mCtx.fillStyle = "#3498db";
            mCtx.fillRect(125 + offset, 300 - waterHeight - size, size, size);
        } else if (time <= 700) {
            // Liquid
            mCtx.fillStyle = "rgba(52, 152, 219, 0.8)";
            mCtx.fillRect(77, 250, 196, 50); 
            
            mCtx.strokeStyle = "rgba(255,255,255,0.5)";
            mCtx.beginPath();
            mCtx.moveTo(80, 250);
            mCtx.bezierCurveTo(130, 245 + Math.sin(Date.now()/200)*5, 220, 255 - Math.sin(Date.now()/200)*5, 270, 250);
            mCtx.stroke();
        } else if (time <= 900) {
            // Boiling
            let boilRatio = (time - 700) / 200;
            let waterLevel = 50 * (1 - boilRatio); 
            
            mCtx.fillStyle = "rgba(52, 152, 219, 0.8)";
            mCtx.fillRect(77, 300 - waterLevel, 196, waterLevel);
            
            for(let i=0; i<5; i++) {
                if(Math.random() > 0.5) {
                    mCtx.beginPath();
                    mCtx.arc(100 + Math.random()*150, 300 - Math.random()*waterLevel, 5, 0, Math.PI*2);
                    mCtx.strokeStyle = "white";
                    mCtx.stroke();
                }
            }

            mCtx.fillStyle = `rgba(200, 200, 200, ${boilRatio * 0.5})`;
            mCtx.fillRect(77, 50, 196, 250);
        } else {
            // Gas
            mCtx.fillStyle = "rgba(200, 200, 200, 0.6)"; 
            mCtx.fillRect(77, 50, 196, 250);
            
            for(let i=0; i<20; i++) {
                mCtx.fillStyle = "rgba(255,255,255,0.5)";
                mCtx.beginPath();
                mCtx.arc(80 + Math.random()*190, 60 + Math.random()*230, 3, 0, Math.PI*2);
                mCtx.fill();
            }
        }
    }

    function drawGraph(currentTime) {
        gCtx.clearRect(0, 0, 350, 350); 
        
        gCtx.strokeStyle = "#eee";
        gCtx.lineWidth = 1;
        gCtx.beginPath();
        for(let i=0; i<350; i+=35) { gCtx.moveTo(0, i); gCtx.lineTo(350, i); gCtx.moveTo(i, 0); gCtx.lineTo(i, 350); }
        gCtx.stroke();

        gCtx.beginPath();
        gCtx.moveTo(40, 310); gCtx.lineTo(330, 310); 
        gCtx.moveTo(40, 310); gCtx.lineTo(40, 20);   
        gCtx.strokeStyle = "#333"; gCtx.lineWidth = 2; gCtx.stroke();
        
        gCtx.font = "12px Arial";
        gCtx.fillStyle = "#666";
        gCtx.fillText("時間 (加熱量)", 250, 330);
        gCtx.fillText("溫度 (°C)", 10, 20);
        
        gCtx.fillText("200", 10, 100); 
        gCtx.fillText("30", 15, 230);  
        gCtx.fillText("-20", 10, 300); 

        const getY = (temp) => {
            if(temp === -20) return 300;
            if(temp === 30) return 230;
            if(temp === 200) return 100;
            if(temp < 30) return 300 - ((temp + 20) / 50) * 70; 
            if(temp < 200) return 230 - ((temp - 30) / 170) * 130;
            return 100 - ((temp - 200) / 50) * 50; 
        };
        
        const getX = (t) => 40 + (t / 1000) * 290;

        gCtx.beginPath();
        gCtx.strokeStyle = "#e74c3c";
        gCtx.lineWidth = 3;
        gCtx.moveTo(getX(0), getY(-20)); 
        
        let segments = [
            { end: 200, tempStart: -20, tempEnd: 30 },   
            { end: 400, tempStart: 30, tempEnd: 30 },     
            { end: 700, tempStart: 30, tempEnd: 200 },    
            { end: 900, tempStart: 200, tempEnd: 200 },   
            { end: 1000, tempStart: 200, tempEnd: 250 }   
        ];

        let lastT = 0;
        for (let seg of segments) {
            if (currentTime > lastT) {
                let targetT = Math.min(currentTime, seg.end);
                let ratio = (targetT - lastT) / (seg.end - lastT);
                let currentSegTemp = seg.tempStart + (seg.tempEnd - seg.tempStart) * ratio;
                
                if (targetT > lastT) { 
                    gCtx.lineTo(getX(targetT), getY(currentSegTemp));
                }
                lastT = seg.end;
            }
        }
        gCtx.stroke();
        
        if (currentTime >= 0) {
            gCtx.fillStyle = "#2c3e50";
            gCtx.beginPath();
            let { temperature } = updatePhysics(currentTime); 
            gCtx.arc(getX(currentTime), getY(temperature), 6, 0, Math.PI*2);
            gCtx.fill();
        }
    }

    // Main Loop
    function animate() {
        if (isPlaying) {
            frameCount++; // Increment frame count
            // Slow down: Only update every 2nd frame
            if (frameCount % 2 === 0) {
                let val = parseInt(slider.value);
                if (val < 1000) {
                    let increment = 1; 
                    slider.value = val + increment; 
                    time = val + increment;
                } else {
                    isPlaying = false;
                    playBtn.textContent = "▶ 重新開始";
                    playBtn.className = "btn-play";
                }
            }
        } else {
            time = parseInt(slider.value);
        }

        let status = updatePhysics(time);
        drawParticles(status.state);
        drawMacro(time); 
        drawGraph(time);
        
        animationId = requestAnimationFrame(animate);
    }

    initParticles();
    animate();

</script>

</body>
</html>