<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>彈簧力學能守恆-彈力位能</title>
    
    

<script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 使用 'Inter' 字體 */
        body {
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        /* 能量條的平滑過渡效果 */
        .energy-bar-fill {
            transition: width 0.1s linear;
        }
        /* 確保畫布高度能正確計算 (修改為 16:9) */
        .canvas-container {
            position: relative;
            width: 100%;
            padding-top: 56.25%; /* 16:9 Aspect Ratio */
            height: 0;
            overflow: hidden;
            cursor: grab; /* 拖曳游標 */
        }
        .canvas-container.dragging {
             cursor: grabbing;
        }
        .canvas-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body class="bg-gray-100">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <h1 class="text-3xl font-bold text-center text-gray-900 mb-6">水平彈簧力學能守恆模擬</h1>

        <div class="flex flex-col lg:flex-row gap-6">

            <!-- 左側: 模擬畫布與控制 -->
            <div class="lg:w-2/3 bg-white rounded-xl shadow-2xl p-4 overflow-hidden">
                <!-- 能量顯示區 -->
                <div class="mb-4 space-y-2">
                    <div class="bg-gray-200 rounded-full h-8 flex items-center p-1 shadow-inner">
                        <span class="text-xs font-medium text-gray-700 w-24 text-right pr-2 shrink-0">總力學能</span>
                        <div id="total-energy-bar" class="flex-grow h-6 bg-red-100 rounded-full overflow-hidden relative">
                            <div id="total-energy-fill" class="energy-bar-fill h-full bg-red-500 rounded-full" style="width: 100%;"></div>
                            <span id="total-energy-text" class="absolute inset-0 text-center text-xs font-bold text-white leading-6" style="text-shadow: 1px 1px 2px rgba(0,0,0,0.5);"></span>
                        </div>
                    </div>
                    <div class="bg-gray-200 rounded-full h-6 flex items-center p-1 shadow-inner">
                        <span class="text-xs font-medium text-gray-700 w-24 text-right pr-2 shrink-0">動能 ($K$)</span>
                        <div id="kinetic-energy-bar" class="flex-grow h-4 bg-blue-100 rounded-full overflow-hidden relative">
                            <div id="kinetic-energy-fill" class="energy-bar-fill h-full bg-blue-500 rounded-full" style="width: 0%;"></div>
                            <span id="kinetic-energy-text" class="absolute inset-0 text-center text-xs font-medium text-white leading-4" style="text-shadow: 1px 1px 2px rgba(0,0,0,0.5);"></span>
                        </div>
                    </div>
                    <div class="bg-gray-200 rounded-full h-6 flex items-center p-1 shadow-inner">
                        <span class="text-xs font-medium text-gray-700 w-24 text-right pr-2 shrink-0">彈力位能 ($U$)</span>
                        <div id="potential-energy-bar" class="flex-grow h-4 bg-green-100 rounded-full overflow-hidden relative">
                            <div id="potential-energy-fill" class="energy-bar-fill h-full bg-green-500 rounded-full" style="width: 100%;"></div>
                            <span id="potential-energy-text" class="absolute inset-0 text-center text-xs font-medium text-white leading-4" style="text-shadow: 1px 1px 2px rgba(0,0,0,0.5);"></span>
                        </div>
                    </div>
                </div>

                <!-- 畫布容器 -->
                <div id="canvas-container" class="canvas-container rounded-xl border border-gray-300 shadow-inner">
                    <canvas id="spring-canvas"></canvas>
                </div>

                <!-- 模擬控制按鈕 -->
                <div class="flex justify-center items-center mt-6 space-x-3">
                    <button id="btn-play" class="flex items-center justify-center px-6 py-2 bg-indigo-600 text-white font-semibold rounded-full shadow-lg hover:bg-indigo-700 transition duration-150 transform hover:scale-105">
                        <svg id="play-icon" class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                        </svg>
                        <span id="play-text">開始</span>
                    </button>
                    <button id="btn-pause" class="flex items-center justify-center px-6 py-2 bg-gray-300 text-gray-700 font-semibold rounded-full shadow-lg hover:bg-gray-400 transition duration-150 transform hover:scale-105">
                        <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 01-1 1H8a1 1 0 01-1-1V8z" clip-rule="evenodd" />
                        </svg>
                        暫停
                    </button>
                    <button id="btn-reset" class="flex items-center justify-center px-6 py-2 bg-red-500 text-white font-semibold rounded-full shadow-lg hover:bg-red-600 transition duration-150 transform hover:scale-105">
                        <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.101 7H7a1 1 0 010 2H3a1 1 0 01-1-1V4a1 1 0 011-1h1zm12 11a1 1 0 01-1 1h-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 011.885-.666A5.002 5.002 0 0014.899 13H13a1 1 0 010-2h4a1 1 0 011 1v4a1 1 0 01-1 1h-1z" clip-rule="evenodd" />
                        </svg>
                        重置
                    </button>
                </div>
            </div>

            <!-- 右側: 參數設定與模式切換 -->
            <div class="lg:w-1/3 space-y-6">
                
                <!-- 初始狀態設定 -->
                <div class="p-4 bg-white rounded-xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-3 text-gray-800">彈簧初始狀態設定</h2>
                    <p class="text-sm text-gray-600 mb-4">拖曳方塊或使用滑桿設定初始位移 $x_0$。初始速度 $v_0$ 預設為 $0$。</p>
                    
                    <div class="mb-4">
                        <label for="initial-displacement" class="block text-sm font-medium text-gray-700">初始位移 ($x_0$, 公尺): <span id="displacement-value" class="font-bold text-indigo-600">0.50</span></label>
                        <input type="range" id="initial-displacement" min="0.0" max="1.0" step="0.01" value="0.5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    </div>
                </div>

                <!-- 參數設定 -->
                <div class="p-4 bg-white rounded-xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-3 text-gray-800">模擬參數設定</h2>
                    
                    <div class="mb-4">
                        <label for="spring-constant" class="block text-sm font-medium text-gray-700">彈簧常數 ($k$, $\text{N/m}$): <span id="constant-value" class="font-bold text-indigo-600">10.0</span></label>
                        <input type="range" id="spring-constant" min="1.0" max="50.0" step="0.1" value="10.0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    </div>

                    <div class="mb-4">
                        <label for="block-mass" class="block text-sm font-medium text-gray-700">方塊質量 ($m$, 公斤): <span id="mass-value" class="font-bold text-indigo-600">1.0</span></label>
                        <input type="range" id="block-mass" min="0.1" max="5.0" step="0.1" value="1.0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    </div>
                </div>
                
                <!-- 模式切換 -->
                <div class="p-4 bg-white rounded-xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-3 text-gray-800">操作模式</h2>
                    <div class="flex space-x-3">
                        <button id="btn-mode-continuous" class="flex-1 px-4 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow-md transition duration-150 opacity-100">連續</button>
                        <button id="btn-mode-step" class="flex-1 px-4 py-2 bg-gray-300 text-gray-700 font-semibold rounded-lg transition duration-150 opacity-70">分段</button>
                    </div>
                    <p class="mt-3 text-sm text-gray-600" id="mode-info">
                        **連續模式**：模擬自動運行，點擊「播放」或「繼續」。
                    </p>
                </div>

            </div>
        </div>

        <!-- 註釋 -->
        <div class="mt-6 p-4 bg-yellow-100 border-l-4 border-yellow-500 text-yellow-800 rounded-lg">
            <p class="font-semibold">力學能守恆說明:</p>
            <p class="text-sm">本模擬忽略摩擦力，總力學能 ($E = K + U$) 應為定值。彈力位能 $U$ 的零點設定在彈簧的自然長度（平衡位置 $x=0$）。</p>
        </div>

    </div>

<script type="module">
    // 必要的 DOM 元素
    const canvas = document.getElementById('spring-canvas');
    const canvasContainer = document.getElementById('canvas-container');
    const ctx = canvas.getContext('2d');
    
    // 控制面板元素
    const initialDisplacementInput = document.getElementById('initial-displacement');
    const displacementValueSpan = document.getElementById('displacement-value');
    const constantInput = document.getElementById('spring-constant');
    const constantValueSpan = document.getElementById('constant-value');
    const massInput = document.getElementById('block-mass');
    const massValueSpan = document.getElementById('mass-value');
    
    const btnPlay = document.getElementById('btn-play');
    const btnPause = document.getElementById('btn-pause');
    const btnReset = document.getElementById('btn-reset');
    const playText = document.getElementById('play-text');
    const btnModeContinuous = document.getElementById('btn-mode-continuous');
    const btnModeStep = document.getElementById('btn-mode-step');
    const modeInfo = document.getElementById('mode-info');

    // 能量顯示元素
    const totalEnergyFill = document.getElementById('total-energy-fill');
    const totalEnergyText = document.getElementById('total-energy-text');
    const kineticEnergyFill = document.getElementById('kinetic-energy-fill');
    const kineticEnergyText = document.getElementById('kinetic-energy-text');
    const potentialEnergyFill = document.getElementById('potential-energy-fill');
    const potentialEnergyText = document.getElementById('potential-energy-text');
    
    // --- 模擬參數 ---
    let k = parseFloat(constantInput.value); // 彈簧常數 (N/m)
    let m = parseFloat(massInput.value);     // 質量 (kg)
    let initialX = parseFloat(initialDisplacementInput.value); // 初始位移 (m)

    // --- 模擬狀態變數 ---
    let x = initialX;           // 當前位移 (m)
    let v = 0;                  // 當前速度 (m/s)
    let totalEnergy = 0;        // 總力學能 (J)
    let potentialMax = 0;       // 最大位能 (用於能量條比例尺)
    
    let simulationState = 'preview'; // 'preview', 'running', 'paused', 'stopped'
    let isStepping = false;          // 是否為分段模式
    
    // --- 繪圖參數 ---
    let equilibriumX_pixels;    // 平衡位置 X 座標 (像素)
    let trackY_pixels;          // 軌道 Y 座標 (像素)
    let pixelsPerMeterX;        // X 軸比例尺 (像素/公尺)
    const blockWidth = 50;      // 方塊寬度 (像素)
    const blockHeight = 50;     // 方塊高度 (像素)
    const springAnchorX = 50;   // 彈簧固定端 X 座標 (像素)
    const maxAmplitude = 1.0;   // 最大振幅 (m)

    let lastTime = 0;
    const dt = 0.01; // 模擬時間步長 (s)
    const renderRate = 1/60; // 渲染頻率 (s)
    let timeAccumulator = 0;
    
    // --- 拖曳控制 ---
    let isDragging = false;
    
    // --- 單位轉換與幾何計算 ---
    
    /**
     * 重新計算畫布尺寸、中心點及比例尺。
     */
    function calculateGeometry() {
        // 確保畫布尺寸為容器尺寸
        const containerWidth = canvasContainer.clientWidth;
        const containerHeight = canvasContainer.clientHeight;
        canvas.width = containerWidth;
        canvas.height = containerHeight;

        // Y 座標設定在中間偏下一點
        trackY_pixels = canvas.height * 0.6; 
        
        // 整個軌道 (2 * maxAmplitude) 佔畫布寬度 (扣除 anchorX 和右側留白) 的比例
        const drawableWidth = canvas.width - springAnchorX - 50;
        
        // 2m (maxAmplitude * 2) 佔用 drawableWidth 的 80%
        pixelsPerMeterX = (drawableWidth * 0.8) / (2 * maxAmplitude);
        
        // 平衡位置: anchorX + (maxAmplitude * pixelsPerMeterX)
        equilibriumX_pixels = springAnchorX + maxAmplitude * pixelsPerMeterX;
    }

    /**
     * 從物理位移 (x) 轉換為螢幕座標 (x_pixels)
     * @param {number} x_meters - 位移 (m)
     * @returns {number} 螢幕 X 座標 (方塊中心)
     */
    function getBlockXPixels(x_meters) {
        return equilibriumX_pixels + x_meters * pixelsPerMeterX;
    }
    
    // --- 物理計算 ---
    
    /**
     * 計算當前狀態的動能
     * @returns {number} 動能 (J)
     */
    function calculateKineticEnergy(current_v) {
        return 0.5 * m * current_v * current_v;
    }

    /**
     * 計算當前狀態的彈力位能
     * @param {number} current_x - 位移 (m)
     * @returns {number} 彈力位能 (J)
     */
    function calculatePotentialEnergy(current_x) {
        return 0.5 * k * current_x * current_x;
    }

    /**
     * 計算並設定總力學能
     */
    function calculateTotalEnergy() {
        // 初始速度為 0，所以初始總能就是初始位能
        const K_init = 0;
        const U_init = calculatePotentialEnergy(initialX); 
        totalEnergy = K_init + U_init;
        
        // 最大位能就是總能量
        potentialMax = totalEnergy;
        
        // 確保 potentialMax 不為零
        if (potentialMax < 1e-6) potentialMax = 1.0; 
    }
    
    // --- 繪圖功能 ---
    
    /**
     * 繪製彈簧
     * @param {number} x - 方塊中心 X 座標 (像素)
     */
    function drawSpring(x) {
        const numCoils = 15;
        const startX = springAnchorX;
        const endX = x - blockWidth / 2;
        const len = endX - startX;
        const coilHeight = 15;
        
        ctx.strokeStyle = '#374151'; // 深灰色
        ctx.lineWidth = 2;
        
        // 繪製固定端
        ctx.beginPath();
        ctx.moveTo(startX, trackY_pixels - 30);
        ctx.lineTo(startX, trackY_pixels + 30);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(startX, trackY_pixels);
        
        if (len > 0) { // 繪製彈簧線圈
            const step = len / (numCoils + 1);
            let currentX = startX;
            let direction = -1; // -1: up, 1: down
            
            for (let i = 0; i < numCoils; i++) {
                currentX += step;
                ctx.lineTo(currentX, trackY_pixels + direction * coilHeight);
                direction *= -1;
            }
            
            ctx.lineTo(endX, trackY_pixels);
        } else {
            // 彈簧被壓縮到極限或重疊
             ctx.lineTo(endX, trackY_pixels);
        }
        ctx.stroke();
    }
    
    /**
     * 繪製方塊
     * @param {number} x - 方塊中心 X 座標 (像素)
     */
    function drawBlock(x) {
        // 繪製方塊
        const blockX = x - blockWidth / 2;
        const blockY = trackY_pixels - blockHeight / 2;
        
        ctx.fillStyle = '#EF4444'; // 紅色
        ctx.fillRect(blockX, blockY, blockWidth, blockHeight);
        
        // 繪製方塊邊框
        ctx.strokeStyle = '#B91C1C';
        ctx.lineWidth = 2;
        ctx.strokeRect(blockX, blockY, blockWidth, blockHeight);
        
        // 標註當前位移
        ctx.fillStyle = '#10B981'; // 綠色
        ctx.font = '14px Arial';
        const displacement = x / pixelsPerMeterX; // 僅用於繪製，實際應使用 x_meters
        ctx.fillText(`x = ${x.toFixed(3)} m`, blockX + blockWidth / 2 - 20, blockY - 10);
    }
    
    /**
     * 繪製參考線
     */
    function drawReferenceLines() {
        // 繪製軌道
        ctx.strokeStyle = '#4B5563'; // 深灰
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(springAnchorX, trackY_pixels);
        ctx.lineTo(canvas.width - 50, trackY_pixels);
        ctx.stroke();
        
        // 繪製平衡位置參考線 (位能零點)
        ctx.strokeStyle = '#9CA3AF'; // 淺灰
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]); // 虛線
        ctx.beginPath();
        ctx.moveTo(equilibriumX_pixels, trackY_pixels - blockHeight);
        ctx.lineTo(equilibriumX_pixels, trackY_pixels + blockHeight);
        ctx.stroke();
        ctx.setLineDash([]); // 恢復實線
        
        // 標註平衡位置 (位能零點)
        ctx.fillStyle = '#4B5563';
        ctx.font = '14px Arial';
        ctx.fillText('x = 0 (平衡位置)', equilibriumX_pixels - 50, trackY_pixels + 30);
    }
    
    /**
     * 更新能量條顯示
     */
    function updateEnergyBars() {
        const K = calculateKineticEnergy(v);
        const U = calculatePotentialEnergy(x);

        // 總能量保持不變
        const totalE = totalEnergy; 
        
        // 比例尺使用 potentialMax
        const maxScale = potentialMax;

        // 更新總能量
        let totalE_ratio = (totalE / maxScale) * 100;
        totalE_ratio = Math.min(100, totalE_ratio); // 限制在 100% 以內
        totalEnergyFill.style.width = `${totalE_ratio}%`;
        totalEnergyText.textContent = `${totalE.toFixed(3)} J`;

        // 更新動能
        const K_ratio = (K / maxScale) * 100;
        kineticEnergyFill.style.width = `${K_ratio}%`;
        kineticEnergyText.textContent = `${K.toFixed(3)} J`;
        
        // 更新位能
        const U_ratio = (U / maxScale) * 100;
        potentialEnergyFill.style.width = `${U_ratio}%`;
        potentialEnergyText.textContent = `${U.toFixed(3)} J`;
    }
    
    /**
     * 主繪圖函式
     */
    function draw() {
        // 清除畫布
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        drawReferenceLines();

        // 取得當前方塊位置 (像素)
        const x_pixels = getBlockXPixels(x);
        
        drawSpring(x_pixels);
        drawBlock(x_pixels);
        
        // 繪製最大振幅線 (初始位置)
        const initialX_pixels = getBlockXPixels(initialX);
        ctx.strokeStyle = 'rgba(16, 185, 129, 0.5)'; // 綠色半透明
        ctx.lineWidth = 2;
        ctx.setLineDash([2, 4]);
        ctx.beginPath();
        ctx.moveTo(initialX_pixels - blockWidth / 2, trackY_pixels - blockHeight / 2 - 5);
        ctx.lineTo(initialX_pixels - blockWidth / 2, trackY_pixels + blockHeight / 2 + 5);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(initialX_pixels + blockWidth / 2, trackY_pixels - blockHeight / 2 - 5);
        ctx.lineTo(initialX_pixels + blockWidth / 2, trackY_pixels + blockHeight / 2 + 5);
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    // --- 模擬核心 ---
    
    /**
     * 進行一步物理模擬 (使用歐拉法)
     */
    function stepSimulation() {
        // 加速度: a = F / m = -k * x / m
        const a = - (k / m) * x;
        
        // 更新速度: v = v + a * dt
        v = v + a * dt;
        
        // 更新位移: x = x + v * dt
        x = x + v * dt;
        
        // 更新能量顯示
        updateEnergyBars();
    }

    /**
     * 渲染迴圈
     * @param {number} currentTime - 當前時間 (ms)
     */
    function animate(currentTime = 0) {
        if (!lastTime) lastTime = currentTime;
        const elapsed = (currentTime - lastTime) / 1000; // 逝去時間 (s)
        lastTime = currentTime;
        
        // 累積時間，以固定步長更新物理
        timeAccumulator += elapsed;
        
        if (simulationState === 'running') {
            const numSteps = Math.floor(timeAccumulator / dt);
            for (let i = 0; i < numSteps; i++) {
                stepSimulation();
            }
            timeAccumulator -= numSteps * dt;
            
        } else if (simulationState === 'paused' && isStepping) {
            // 分段模式下，每次點擊「下一步」才執行一次 stepSimulation
            // 這裡的 animate 只是為了維持渲染，物理更新在 handlePlayPause 裡
            timeAccumulator = 0; 
        } else {
            // 'preview' 或 'stopped'
            timeAccumulator = 0; 
        }
        
        // 渲染繪圖
        draw();
        
        // 請求下一幀
        requestAnimationFrame(animate);
    }
    
    // --- 狀態/控制邏輯 ---
    
    /**
     * 重置模擬狀態到初始設定
     */
    function resetSimulation() {
        k = parseFloat(constantInput.value);
        m = parseFloat(massInput.value);
        initialX = parseFloat(initialDisplacementInput.value);

        x = initialX;
        v = 0;
        
        calculateGeometry(); // 重新計算幾何 (比例尺可能改變)
        calculateTotalEnergy(); // 重新計算總能量

        simulationState = 'preview'; // 重置為預覽狀態
        
        // 更新按鈕狀態
        btnPlay.disabled = false;
        playText.textContent = isStepping ? "下一步" : "開始";
        btnPause.disabled = true;

        // 立即更新繪圖和能量條
        draw();
        updateEnergyBars();
    }
    
    /**
     * 處理播放/暫停/下一步邏輯
     */
    function handlePlayPause() {
        if (isStepping) {
            // 分段模式
            if (simulationState === 'preview' || simulationState === 'stopped' || simulationState === 'paused') {
                // 從靜止狀態開始或繼續
                stepSimulation();
                simulationState = 'paused'; // 執行一步後仍保持暫停狀態
                btnPause.disabled = true; // 分段模式下，暫停按鈕無意義
            }
        } else {
            // 連續模式
            if (simulationState === 'preview' || simulationState === 'stopped') {
                // 從靜止開始
                simulationState = 'running';
                playText.textContent = "播放中...";
                btnPause.disabled = false;
                lastTime = 0; // 重置時間，防止第一幀時間過長
            } else if (simulationState === 'paused') {
                // 繼續
                simulationState = 'running';
                playText.textContent = "播放中...";
                btnPause.disabled = false;
                lastTime = 0;
            } else {
                // 暫停 (連點播放按鈕時)
                pauseContinuous();
            }
        }
        updateButtonText();
    }
    
    /**
     * 連續模式下的暫停
     */
    function pauseContinuous() {
        if (simulationState === 'running') {
            simulationState = 'paused';
            btnPause.disabled = true; // 暫停後不能再按暫停
        }
    }
    
    /**
     * 更新播放按鈕文字
     */
    function updateButtonText() {
        if (isStepping) {
             playText.textContent = "下一步";
        } else {
            if (simulationState === 'paused') {
                playText.textContent = "繼續";
            } else if (simulationState === 'running') {
                playText.textContent = "播放中...";
            } else { // preview 或 stopped
                playText.textContent = "開始";
            }
        }
    }
    
    // --- 拖曳事件處理 ---

    /**
     * 拖曳時更新預覽狀態
     * @param {number} new_x_meters - 新的位移 (m)
     */
    function updatePreviewFromDrag(new_x_meters) {
        // 限制在最大振幅內
        new_x_meters = Math.max(-maxAmplitude, Math.min(maxAmplitude, new_x_meters));
        
        // 如果是 preview 或 stopped 狀態，才允許拖曳
        if (simulationState === 'preview' || simulationState === 'stopped') {
            x = new_x_meters;
            v = 0; // 拖曳時速度為零
            
            // 更新滑桿 (以絕對值顯示)
            const newXabs = Math.abs(new_x_meters);
            initialDisplacementInput.value = newXabs.toFixed(2);
            displacementValueSpan.textContent = newXabs.toFixed(2);
            
            // 更新初始位移參數
            initialX = new_x_meters;

            // 重新計算總能量 (K=0, U由新位移決定)
            calculateTotalEnergy();
        }
    }

    function handleDragStart(event) {
        event.preventDefault();
        
        if (simulationState === 'running') return; // 模擬運行時不允許拖曳

        let rect = canvas.getBoundingClientRect();
        let clientX = event.clientX || event.touches[0].clientX;
        let clientY = event.clientY || event.touches[0].clientY;

        const mx = clientX - rect.left;
        const my = clientY - rect.top;

        // 檢查是否點擊在方塊上 (使用當前 x 座標)
        const blockX_pixels = getBlockXPixels(x);
        const blockY_pixels = trackY_pixels - blockHeight / 2;
        
        const isClickedOnBlock = (
            mx >= blockX_pixels - blockWidth / 4 && // 稍微寬鬆的左側
            mx <= blockX_pixels + blockWidth * 1.25 && // 稍微寬鬆的右側
            my >= blockY_pixels - 10 && 
            my <= blockY_pixels + blockHeight + 10
        );

        if (isClickedOnBlock) {
            isDragging = true;
            canvasContainer.classList.add('dragging');
            // 如果從暫停狀態拖曳，要確保回到 preview 狀態 (靜態初始設定)
            simulationState = 'preview'; 
            updateButtonText();
        }
    }

    function handleDragMove(event) {
        if (!isDragging) return;
        event.preventDefault();
        
        let rect = canvas.getBoundingClientRect();
        let clientX = event.clientX || event.touches[0].clientX;
        // let clientY = event.clientY || event.touches[0].clientY; // Y 軸不重要

        const mx = clientX - rect.left;
        
        // 拖曳時，方塊中心應跟隨滑鼠/觸控點
        // mx 減去方塊寬度的一半 (如果拖曳點是方塊的邊緣，則需要修正)
        // 這裡我們假設拖曳點就是方塊中心
        
        // 從像素 x 轉回物理位移 x
        let new_x_meters = (mx - (equilibriumX_pixels) ) / pixelsPerMeterX; // (修正) 拖曳時以方塊中心為準
        
        // 限制在最大振幅內
        new_x_meters = Math.max(-maxAmplitude, Math.min(maxAmplitude, new_x_meters));
        
        updatePreviewFromDrag(new_x_meters);
    }

    function handleDragEnd(event) {
        if (!isDragging) return;
        isDragging = false;
        canvasContainer.classList.remove('dragging');
        // 狀態已在 move 時更新，這裡不需要再做 setPreviewState
    }

    // 綁定滑鼠事件
    canvas.addEventListener('mousedown', handleDragStart);
    canvas.addEventListener('mousemove', handleDragMove);
    canvas.addEventListener('mouseup', handleDragEnd);
    canvas.addEventListener('mouseleave', handleDragEnd); 

    // 綁定觸控事件
    canvas.addEventListener('touchstart', handleDragStart);
    canvas.addEventListener('touchmove', handleDragMove);
    canvas.addEventListener('touchend', handleDragEnd);
    canvas.addEventListener('touchcancel', handleDragEnd);


    // --- 事件監聽 ---
    
    // 參數變化
    initialDisplacementInput.addEventListener('input', (e) => {
        displacementValueSpan.textContent = e.target.value;
        // x_m 應為滑桿值的絕對值。拖曳時我們允許負值。
        // 當使用滑桿時，我們假設從靜止開始，並位於正向或負向最大位移處。
        // 這裡設定 initialX 為滑桿值的**正負號**乘上滑桿值 (為了重置時保持方向)
        // 由於滑桿 min=0, max=1.0, 這裡我們強制取正值作為絕對振幅
        const newAbsX = parseFloat(e.target.value);
        
        // 重置時，如果當前 x 是負的，則保持負號
        if (x < 0) {
            initialX = -newAbsX;
        } else {
            initialX = newAbsX;
        }
        
        resetSimulation(); // 位移變化，重置模擬
    });
    
    constantInput.addEventListener('input', (e) => {
        constantValueSpan.textContent = e.target.value;
        resetSimulation(); // 彈簧常數變化，重置模擬
    });
    
    massInput.addEventListener('input', (e) => {
        massValueSpan.textContent = e.target.value;
        resetSimulation(); // 質量變化，重置模擬
    });
    
    // 控制按鈕
    btnPlay.addEventListener('click', handlePlayPause);
    btnPause.addEventListener('click', pauseContinuous);
    btnReset.addEventListener('click', resetSimulation);
    
    // 模式切換
    btnModeContinuous.addEventListener('click', () => {
        isStepping = false;
        // 更新按鈕樣式
        btnModeContinuous.classList.replace('bg-gray-300', 'bg-indigo-600');
        btnModeContinuous.classList.replace('text-gray-700', 'text-white');
        btnModeContinuous.classList.replace('opacity-70', 'opacity-100');
        btnModeContinuous.classList.add('shadow-md');

        btnModeStep.classList.replace('bg-indigo-600', 'bg-gray-300');
        btnModeStep.classList.replace('text-white', 'text-gray-700');
        btnModeStep.classList.replace('opacity-100', 'opacity-70');
        btnModeStep.classList.remove('shadow-md');
        
        // 更新資訊
        modeInfo.innerHTML = `**連續模式**：模擬自動運行，點擊「播放」或「繼續」。`;

        // 如果不是運行狀態，更新 Play 按鈕文字
        if (simulationState !== 'running') {
            updateButtonText();
        }
    });

    btnModeStep.addEventListener('click', () => {
        isStepping = true;
        // 更新按鈕樣式
        btnModeStep.classList.replace('bg-gray-300', 'bg-indigo-600');
        btnModeStep.classList.replace('text-gray-700', 'text-white');
        btnModeStep.classList.replace('opacity-70', 'opacity-100');
        btnModeStep.classList.add('shadow-md');

        btnModeContinuous.classList.replace('bg-indigo-600', 'bg-gray-300');
        btnModeContinuous.classList.replace('text-white', 'text-gray-700');
        btnModeContinuous.classList.replace('opacity-100', 'opacity-70');
        btnModeContinuous.classList.remove('shadow-md');
        
        // 更新資訊
        modeInfo.innerHTML = `**分段模式**：每次點擊「下一步」，模擬前進一個時間步 ($\Delta t=${dt}\text{s}$)。`;

        // 更新 Play 按鈕文字
        playText.textContent = "下一步";
        // 切換到分段模式時，如果不是停止狀態，則自動暫停
        if (simulationState === 'running') {
            pauseContinuous();
        }
    });


    // (修改) 延遲執行，確保畫布尺寸正確
    window.addEventListener('load', () => {
        calculateGeometry(); // (修改)
        resetSimulation(); // 初始化所有狀態
        window.addEventListener('resize', () => {
            calculateGeometry();
            draw(); // 視窗大小改變時重繪
        });
        animate(); // 開始渲染迴圈
    });
</script>
</body>
</html>
