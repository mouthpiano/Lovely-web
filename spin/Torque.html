<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>力矩</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Inter 字體 */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+TC:wght@400;500;700&display=swap');
        body {
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
            background-color: #f8fafc; /* cool-gray-50 */
        }
        /* 畫布 */
        canvas {
            @apply bg-white border border-gray-300 rounded-lg shadow-sm;
        }
        /* 控制項 */
        .control-panel {
            @apply bg-white p-6 rounded-lg shadow-md;
        }
        .control-panel label {
            @apply block text-sm font-medium text-gray-700 mb-2;
        }
        .control-panel select, .control-panel input[type="range"] {
            @apply w-full mt-1;
        }
    </style>
</head>
<body class="min-h-screen p-4 md:p-8">

    <div class="max-w-7xl mx-auto">
        <h1 class="text-3xl font-bold text-center text-blue-800 mb-6">力矩</h1>

        <!-- 內容 -->
        <div>
            <!-- 第一部分：力矩 -->
            <div id="torque-content" class="block">
                <div class="flex flex-col md:flex-row gap-6">
                    
                    <!-- 左側控制面板 -->
                    <div class="control-panel w-full md:w-1/4">
                        <h2 class="text-xl font-bold text-gray-800 mb-4">力矩控制變因</h2>
                        
                        <div class="mb-4">
                            <label for="torque-variable">選擇要改變的變因：</label>
                            <select id="torque-variable" class="block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
                                <option value="force">1. 施力大小</option>
                                <option value="position">2. 施力點位置</option>
                                <option value="angle">3. 施力角度</option>
                            </select>
                        </div>

                        <!-- 施力大小控制 -->
                        <div id="force-control" class="space-y-4 control-group">
                            <label for="force-slider">施力大小 (F):</label>
                            <div class="flex items-center gap-2">
                                <span>F</span>
                                <input id="force-slider" type="range" min="1" max="2" value="1" step="1" class="w-full">
                                <span>2F</span>
                            </div>
                            <p class="text-sm text-gray-600">位置和角度固定 (90°)</p>
                        </div>

                        <!-- 施力點位置控制 -->
                        <div id="position-control" class="space-y-4 control-group hidden">
                            <p class="text-sm text-gray-600">請在右側畫布上拖曳施力點 (藍色圓圈)。</p>
                            <p class="text-sm text-gray-600">施力大小和角度固定 (90°)</p>
                        </div>

                        <!-- 施力角度控制 -->
                        <div id="angle-control" class="space-y-4 control-group hidden">
                            <label for="angle-slider">施力角度 (θ): <span id="angle-value">90°</span></label>
                            <input id="angle-slider" type="range" min="0" max="315" value="90" step="45" class="w-full">
                            <p class="text-sm text-gray-600">施力大小和位置固定</p>
                        </div>

                        <hr class="my-6">
                        <button id="start-torque-btn" class="w-full px-4 py-2 bg-green-500 text-white rounded-lg shadow-md hover:bg-green-600 text-lg font-bold">
                            開始轉動
                        </button>
                    </div>

                    <!-- 右側畫布 -->
                    <div class="w-full md:w-3/4">
                        <canvas id="torque-canvas" width="800" height="400"></canvas>
                        <div class="text-center mt-4">
                            <p class="text-lg font-semibold">
                                計算力矩： <span id="torque-calculation">r * F * sin(θ)</span> = <span id="torque-value" class="text-blue-600">0</span>
                            </p>
                            <p class="text-sm text-gray-500">(r=力臂, F=施力, θ=角度)</p>
                        </div>
                    </div>
                </div>

                <!-- 最大轉動幅度組合 -->
                <hr class="my-8 border-t-2 border-gray-200">
                <div class="mt-6">
                    <h2 class="text-2xl font-bold text-gray-800 mb-4">提問：最大轉動幅度的組合是？</h2>
                    <div class="control-panel flex flex-col md:flex-row gap-4 items-center">
                        <div>
                            <label for="combo-force">施力大小：</label>
                            <select id="combo-force" class="p-2 border border-gray-300 rounded-md shadow-sm">
                                <option value="1">F (小)</option>
                                <option value="2">2F (大)</option>
                            </select>
                        </div>
                        <div>
                            <label for="combo-position">施力位置：</label>
                            <select id="combo-position" class="p-2 border border-gray-300 rounded-md shadow-sm">
                                <option value="200">最遠</option>
                                <option value="100">中間</option>
                                <option value="0">支點</option>
                            </select>
                        </div>
                        <div>
                            <label for="combo-angle">施力角度：</label>
                            <select id="combo-angle" class="p-2 border border-gray-300 rounded-md shadow-sm">
                                <option value="0">0°</option>
                                <option value="45">45°</option>
                                <option value="90">90°</option>
                                <option value="135">135°</option>
                                <option value="180">180°</option>
                                <option value="225">225°</option>
                                <option value="270">270°</option>
                                <option value="315">315°</option>
                            </select>
                        </div>
                        <button id="start-combo-btn" class="w-full md:w-auto px-6 py-2 bg-blue-500 text-white rounded-lg shadow-md hover:bg-blue-600 text-lg font-bold mt-4 md:mt-0">
                            測試組合
                        </button>
                    </div>
                    <div class="w-full mt-4">
                        <canvas id="combo-canvas" width="800" height="400"></canvas>
                    </div>
                </div>
            </div>
            
            <!-- 第二部分：槓桿原理 (已移除) -->

        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- 頁籤切換 (已移除) ---
            let isTorqueAnimating = false;
            let isComboAnimating = false;

            // --- 第一部分：力矩 ---
            const torqueCanvas = document.getElementById('torque-canvas');
            const torqueCtx = torqueCanvas.getContext('2d');
            const variableSelect = document.getElementById('torque-variable');
            const controlGroups = document.querySelectorAll('.control-group');
            
            const forceSlider = document.getElementById('force-slider');
            const angleSlider = document.getElementById('angle-slider');
            const angleValue = document.getElementById('angle-value');
            const startTorqueBtn = document.getElementById('start-torque-btn');

            const torqueValueEl = document.getElementById('torque-value');
            const torqueCalcEl = document.getElementById('torque-calculation');

            const comboCanvas = document.getElementById('combo-canvas');
            const comboCtx = comboCanvas.getContext('2d');
            const comboForce = document.getElementById('combo-force');
            const comboPosition = document.getElementById('combo-position');
            const comboAngle = document.getElementById('combo-angle');
            const startComboBtn = document.getElementById('start-combo-btn');

            const leverLength = 200; 
            const pivot = { x: 325, y: 200 }; // 支點置中
            let forceMag = 20; 
            let forcePos = leverLength; 
            let forceAngle = 90; 
            
            let rotation = 0; 
            let targetRotation = 0;
            let isDragging = false;

            let comboRotation = 0;
            let comboTargetRotation = 0;

            // 繪製力矩畫布 (通用函數)
            function drawGenericTorque(ctx, p, len, rot, fPos, fAngle, fMag) {
                const w = ctx.canvas.width;
                const h = ctx.canvas.height;
                ctx.clearRect(0, 0, w, h);

                // 修正：先畫支點 (不會動)
                ctx.fillStyle = '#3b82f6'; // blue-500
                ctx.beginPath();
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(p.x - 25, p.y + 50);
                ctx.lineTo(p.x + 25, p.y + 50);
                ctx.closePath();
                ctx.fill();

                // 儲存狀態，平移並旋轉
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(rot * Math.PI / 180);

                // 繪製槓桿
                ctx.fillStyle = '#9ca3af'; // gray-400
                ctx.fillRect(-50, -10, len + 50, 20); 

                // 施力點
                const handleX = fPos; 
                const handleY = 0;
                
                // 繪製施力向量
                const currentForce = fMag; 
                const arrowLength = currentForce * 3;
                
                const angleRad = fAngle * Math.PI / 180; 
                
                const arrowEndX = handleX + arrowLength * Math.cos(angleRad);
                const arrowEndY = handleY + arrowLength * Math.sin(angleRad);

                ctx.strokeStyle = '#ef4444'; // red-500
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(handleX, handleY);
                ctx.lineTo(arrowEndX, arrowEndY);
                
                // 畫箭頭
                const headlen = 10;
                const angle = Math.atan2(arrowEndY - handleY, arrowEndX - handleX);
                ctx.lineTo(arrowEndX - headlen * Math.cos(angle - Math.PI / 6), arrowEndY - headlen * Math.sin(angle - Math.PI / 6));
                ctx.moveTo(arrowEndX, arrowEndY);
                ctx.lineTo(arrowEndX - headlen * Math.cos(angle + Math.PI / 6), arrowEndY - headlen * Math.sin(angle + Math.PI / 6));
                ctx.stroke();
                
                ctx.restore(); // 還原狀態 (旋轉和平移)
            }

            // 繪製主畫布
            function drawTorque() {
                let currentForce = variableSelect.value === 'force' ? forceSlider.value * forceMag : forceMag;
                let currentPos = forcePos;
                let currentAngle = forceAngle;

                if (variableSelect.value === 'force') {
                    currentPos = leverLength;
                    currentAngle = 90;
                } else if (variableSelect.value === 'position') {
                    currentForce = forceMag;
                    currentAngle = 90;
                } else if (variableSelect.value === 'angle') {
                    currentPos = leverLength;
                    currentForce = forceMag;
                }

                drawGenericTorque(torqueCtx, pivot, leverLength, rotation, currentPos, currentAngle, currentForce);
                
                // 拖曳點
                if (variableSelect.value === 'position') {
                    torqueCtx.save();
                    torqueCtx.translate(pivot.x, pivot.y);
                    torqueCtx.rotate(rotation * Math.PI / 180);
                    torqueCtx.fillStyle = '#3b82f6'; // blue-500
                    torqueCtx.beginPath();
                    torqueCtx.arc(forcePos, 0, 10, 0, 2 * Math.PI);
                    torqueCtx.fill();
                    torqueCtx.restore();
                }
            }
            
            // 力矩動畫迴圈
            function animateTorque() {
                if (!isTorqueAnimating) return; 

                rotation += (targetRotation - rotation) * 0.1;
                drawTorque();
                
                if (Math.abs(targetRotation - rotation) < 0.01) {
                    rotation = targetRotation;
                    isTorqueAnimating = false; 
                    drawTorque(); 
                } else {
                    requestAnimationFrame(animateTorque); 
                }
            }

            // 更新力矩計算
            function updateTorque() {
                let r = forcePos;
                let F = variableSelect.value === 'force' ? forceSlider.value * forceMag : forceMag;
                let theta = forceAngle;

                if (variableSelect.value === 'force') {
                    r = leverLength;
                    theta = 90;
                } else if (variableSelect.value === 'position') {
                    F = forceMag;
                    theta = 90;
                    if (r < 0) r = 0; 
                } else if (variableSelect.value === 'angle') {
                    r = leverLength;
                    F = forceMag;
                }
                
                const torqueRatio = (r / 200) * (F / 40) * Math.sin(theta * Math.PI / 180);
                
                torqueCalcEl.innerHTML = `${r.toFixed(0)} * ${F/forceMag}F * sin(${theta}°)`;
                
                // 修正：使用平方來加大轉動幅度差異
                const maxRotation = 45; 
                const amplifiedRatio = Math.pow(Math.abs(torqueRatio), 1.5) * Math.sign(torqueRatio);
                
                targetRotation = amplifiedRatio * maxRotation; 
                torqueValueEl.textContent = (torqueRatio * 400).toFixed(2);
                
                if (r === 0 || theta % 180 === 0) {
                    targetRotation = 0;
                    torqueValueEl.textContent = "0 (不轉動)";
                }
            }

            // 重設力矩狀態
            function resetTorqueState() {
                isTorqueAnimating = false;
                rotation = 0;
                updateTorque();
                drawTorque();
            }

            variableSelect.addEventListener('change', (e) => {
                controlGroups.forEach(group => group.classList.add('hidden'));
                document.getElementById(e.target.value + '-control').classList.remove('hidden');
                
                forceSlider.value = 1;
                forcePos = leverLength;
                angleSlider.value = 90;
                angleValue.textContent = '90°';
                forceAngle = 90;
                
                resetTorqueState();
            });

            forceSlider.addEventListener('input', resetTorqueState);
            angleSlider.addEventListener('input', (e) => {
                forceAngle = Number(e.target.value);
                angleValue.textContent = `${forceAngle}°`;
                resetTorqueState();
            });

            // 修正：在 mousedown 時重設
            torqueCanvas.addEventListener('mousedown', (e) => {
                if (variableSelect.value === 'position') {
                    isDragging = true;
                    torqueCanvas.style.cursor = 'grabbing';
                    resetTorqueState(); // 拖曳開始時重設
                }
            });
            
            torqueCanvas.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const rect = torqueCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                // 修正：計算旋轉後的 X 座標
                const canvasX = mouseX - pivot.x;
                const canvasY = (e.clientY - rect.top) - pivot.y;
                const rotRad = -rotation * Math.PI / 180;
                const rotatedX = canvasX * Math.cos(rotRad) - canvasY * Math.sin(rotRad);

                forcePos = Math.max(0, Math.min(leverLength, rotatedX));
                updateTorque(); // 拖曳時更新計算
                drawTorque();   // 拖曳時重繪
            });
            torqueCanvas.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    torqueCanvas.style.cursor = 'default';
                }
            });
            torqueCanvas.addEventListener('mouseleave', () => {
                if (isDragging) {
                    isDragging = false;
                    torqueCanvas.style.cursor = 'default';
                }
            });


            startTorqueBtn.addEventListener('click', () => {
                rotation = 0; 
                updateTorque(); 

                if (!isTorqueAnimating) {
                    isTorqueAnimating = true;
                    animateTorque();
                }
            });

            // --- 組合畫布的邏輯 ---
            function drawCombo() {
                const f_val = Number(comboForce.value);
                const r_val = Number(comboPosition.value);
                const a_val = Number(comboAngle.value);
                
                const currentForce = f_val * forceMag;
                const handleX = r_val;
                
                drawGenericTorque(comboCtx, pivot, leverLength, comboRotation, handleX, a_val, currentForce);
            }

            function animateCombo() {
                if (!isComboAnimating) return; 

                comboRotation += (comboTargetRotation - comboRotation) * 0.1;
                drawCombo();
                
                if (Math.abs(comboTargetRotation - comboRotation) < 0.01) {
                    comboRotation = comboTargetRotation;
                    isComboAnimating = false;
                    drawCombo();
                } else {
                    requestAnimationFrame(animateCombo);
                }
            }

            function resetComboState() {
                isComboAnimating = false;
                comboRotation = 0;
                comboTargetRotation = 0;
                drawCombo();
            }

            comboForce.addEventListener('change', resetComboState);
            comboPosition.addEventListener('change', resetComboState);
            comboAngle.addEventListener('change', resetComboState);

            startComboBtn.addEventListener('click', () => {
                comboRotation = 0; 

                const f_val = Number(comboForce.value);
                const r_val = Number(comboPosition.value);
                const a_val = Number(comboAngle.value);

                const comboTorqueRatio = (r_val / 200) * (f_val * forceMag / 40) * Math.sin(a_val * Math.PI / 180);
                
                const maxRotation = 45;
                const amplifiedRatio = Math.pow(Math.abs(comboTorqueRatio), 1.5) * Math.sign(comboTorqueRatio);
                
                comboTargetRotation = amplifiedRatio * maxRotation;
                
                if (r_val === 0 || a_val % 180 === 0) {
                    comboTargetRotation = 0;
                }

                if (!isComboAnimating) {
                    isComboAnimating = true;
                    animateCombo();
                }
            });


            // --- 第二部分：槓桿原理 (已移除) ---
            
            // --- 初始化 ---
            isTorqueAnimating = false;
            isComboAnimating = false;
            
            // 初始化第一部分
            resetTorqueState(); 
            resetComboState(); 
            
            // 靜態繪製
            drawTorque();
            drawCombo();
            
        });
    </script>
</body>
</html>